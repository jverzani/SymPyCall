<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A SymPyPythonCall introduction · SymPyPythonCall</title><meta name="title" content="A SymPyPythonCall introduction · SymPyPythonCall"/><meta property="og:title" content="A SymPyPythonCall introduction · SymPyPythonCall"/><meta property="twitter:title" content="A SymPyPythonCall introduction · SymPyPythonCall"/><meta name="description" content="Documentation for SymPyPythonCall."/><meta property="og:description" content="Documentation for SymPyPythonCall."/><meta property="twitter:description" content="Documentation for SymPyPythonCall."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymPyPythonCall</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SymPyPythonCall</a></li><li><a class="tocitem" href="../docstrings/">Docstrings</a></li><li class="is-active"><a class="tocitem" href>A SymPyPythonCall introduction</a><ul class="internal"><li><a class="tocitem" href="#Symbols"><span>Symbols</span></a></li><li><a class="tocitem" href="#Substitution"><span>Substitution</span></a></li><li><a class="tocitem" href="#Conversion-from-symbolic-to-numeric"><span>Conversion from symbolic to numeric</span></a></li><li><a class="tocitem" href="#Algebraic-expressions"><span>Algebraic expressions</span></a></li><li><a class="tocitem" href="#Rational-expressions:-apart,-together,-cancel"><span>Rational expressions: apart, together, cancel</span></a></li><li><a class="tocitem" href="#Powers"><span>Powers</span></a></li><li><a class="tocitem" href="#Trigonometric-simplification"><span>Trigonometric simplification</span></a></li><li><a class="tocitem" href="#Coefficients"><span>Coefficients</span></a></li><li><a class="tocitem" href="#Polynomial-roots:-solve,-real_roots,-polyroots,-nroots"><span>Polynomial roots: solve, real_roots, polyroots, nroots</span></a></li><li><a class="tocitem" href="#The-solve-function"><span>The solve function</span></a></li></ul></li><li><a class="tocitem" href="../overview/">Basic overview</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>A SymPyPythonCall introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A SymPyPythonCall introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyPythonCall.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jverzani/SymPyPythonCall.jl/blob/main/docs/src/introduction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-SymPyPythonCall-introduction"><a class="docs-heading-anchor" href="#A-SymPyPythonCall-introduction">A SymPyPythonCall introduction</a><a id="A-SymPyPythonCall-introduction-1"></a><a class="docs-heading-anchor-permalink" href="#A-SymPyPythonCall-introduction" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">SymPyPythonCall</header><div class="admonition-body"><p><code>SymPyPythonCall.jl</code> is like the <code>SymPy.jl</code> package in that it allows access to the underlying <code>SymPy</code> library for <code>Python</code> from within <code>Julia</code>.</p><p>Whereas <code>SymPy.jl</code> uses the <code>PyCall</code> package, <code>SymPyPythonCall</code> uses the <code>PythonCall</code> package to provide the bridge between <code>Julia</code> and <code>Python</code>.</p><p>Though the two packages work similarly, there are a few differences:</p><ul><li><code>@vars</code> of <code>SymPy</code> is not provided; use the more powerful <code>@syms</code> macro only</li><li><code>Base.show</code> isn&#39;t <em>currently</em> using pretty printing</li><li>Sets are handled differently, with finite sets converted to <code>Julia</code> <code>Set</code>s.</li><li>Currently <code>Q</code> is not exported. (only the slant italic Q is currently)</li><li>Matrix support may not be complete.</li><li><code>sympy.poly</code> <em>not</em> <code>sympy.Poly</code></li><li>The form <code>limit(ex, x, c)</code> is not provided; use <code>limit(ex, x=&gt;c)</code> or <code>sympy.limit</code></li><li>no new special functions exported, just the ones in SpecialFunctions.jl</li></ul></div></div><p>This document provides an introduction to using <code>SymPy</code> within <code>Julia</code>. It owes an enormous debt to the tutorial for using SymPy within Python which may be found <a href="http://docs.sympy.org/dev/tutorial/index.html">here</a>. The overall structure and many examples are taken from that work, with adjustments and additions to illustrate the differences due to using <code>SymPy</code> within <code>Julia</code>.</p><p>After installing <code>SymPyPythonCall</code> we must first load it into <code>Julia</code> with the standard command <code>using</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; using SymPyPythonCall</code></pre><h2 id="Symbols"><a class="docs-heading-anchor" href="#Symbols">Symbols</a><a id="Symbols-1"></a><a class="docs-heading-anchor-permalink" href="#Symbols" title="Permalink"></a></h2><p>At the core of <code>SymPy</code> is the introduction of symbolic variables that differ quite a bit from <code>Julia</code>&#39;s variables. Symbolic variables do not immediately evaluate to a value, rather the &quot;symbolicness&quot; propagates when interacted with. To keep things manageable, SymPy does some simplifications along the way.</p><p>Symbolic expressions are primarily of the <code>Sym</code> type and can be constructed in the standard way:</p><pre><code class="language-julia-repl hljs">julia&gt; x = Sym(&quot;x&quot;)
x</code></pre><p>This creates a symbolic object <code>x</code>, which can be manipulated through further function calls.</p><p>There is the <code>@syms</code> macro that makes creating multiple variables a bit less typing, as it creates variables in the local scope – no assignment is necessary. Compare these similar ways to create symbolic variables:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms a b c
(a, b, c)

julia&gt; a,b,c = Sym(&quot;a,b,c&quot;)
3-element Vector{Sym}:
 a
 b
 c</code></pre><p>Here are two ways to make related variables:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms xs[1:5]
(Sym[xs₁, xs₂, xs₃, xs₄, xs₅],)

julia&gt; ys = [Sym(&quot;y$i&quot;) for i in 1:5]
5-element Vector{Sym}:
 y1
 y2
 y3
 y4
 y5</code></pre><p>The former much more succinct, but the latter pattern of use when the number of terms is a variable.</p><p>The <code>@syms</code> macro is recommended, and will be modeled in the following, as it makes the specification of assumptions and symbolic functions more natural.</p><h3 id="Assumptions"><a class="docs-heading-anchor" href="#Assumptions">Assumptions</a><a id="Assumptions-1"></a><a class="docs-heading-anchor-permalink" href="#Assumptions" title="Permalink"></a></h3><p>Finally, there is the <code>symbols</code> constructor for producing symbolic objects. With <code>symbols</code> (and with <code>@syms</code>) it is possible to pass assumptions onto the variables. A list of possible assumptions is <a href="http://docs.sympy.org/dev/modules/core.html#module-sympy.core.assumptions">here</a>. Some examples are:</p><pre><code class="language-julia-repl hljs">julia&gt; u = symbols(&quot;u&quot;)
u

julia&gt; x = symbols(&quot;x&quot;, real=true)
x

julia&gt; y1, y2 = symbols(&quot;y1, y2&quot;, positive=true)
2-element Vector{Sym}:
 y1
 y2

julia&gt; alpha = symbols(&quot;alpha&quot;, integer=true, positive=true)
alpha
</code></pre><p>As seen, the <code>symbols</code> function can be used to make one or more variables with zero, one or more assumptions.</p><p>We jump ahead for a second to illustrate, but here we see that <code>solve</code> will respect these assumptions, by failing to find solutions to these equations:</p><pre><code class="language-julia-repl hljs">julia&gt; solve(x^2 + 1)   # ±i are not real
Sym[]
</code></pre><pre><code class="language-julia-repl hljs">julia&gt; solve(y1 + 1)    # -1 is not positive
Sym[]
</code></pre><p>The <code>@syms</code> macro allows annotations, akin to type annotations, to specify assumptions on new variables:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms u1::positive u2::positive
(u1, u2)

julia&gt; solve(u1 + u2)  # empty, though solving u1 - u2 is not.
Sym[]</code></pre><p>Additionally you can rename arguments using pair notation:</p><pre><code class="nohighlight hljs">julia&gt; @syms a1=&gt;&quot;α₁&quot; a2=&gt;&quot;α₂&quot;
(α₁, α₂)</code></pre><p>In this example, the Julia variables <code>a1</code> and <code>a2</code> are defined to store SymPy symbols with the &quot;pretty&quot; names <code>α₁</code> and <code>α₂</code> respectively.</p><p>As can be seen, there are several ways to create symbolic values, but the recommended way is to use <code>@syms</code>. One caveat is that one can&#39;t use <code>Sym</code> to create a variable from a function name in Base.</p><h3 id="Special-constants"><a class="docs-heading-anchor" href="#Special-constants">Special constants</a><a id="Special-constants-1"></a><a class="docs-heading-anchor-permalink" href="#Special-constants" title="Permalink"></a></h3><p><code>Julia</code> has its math constants, like <code>pi</code> and <code>e</code>, <code>SymPy</code> as well. A few of these have <code>Julia</code> counterparts provided by <code>SymPyPythonCall</code>. For example, these two constants are defined (where <code>oo</code> is for infinity):</p><pre><code class="language-julia-repl hljs">julia&gt; PI,  oo
(pi, oo)
</code></pre><p>Numeric values themselves can be symbolic. This example shows the difference. The first <code>asin</code> call dispatches to <code>Julia</code>&#39;s <code>asin</code> function, the second to <code>SymPy</code>&#39;s:</p><pre><code class="language-julia-repl hljs">julia&gt; [asin(1), asin(Sym(1))]
2-element Vector{Sym}:
 1.5707963267948966
               pi/2
</code></pre><h2 id="Substitution"><a class="docs-heading-anchor" href="#Substitution">Substitution</a><a id="Substitution-1"></a><a class="docs-heading-anchor-permalink" href="#Substitution" title="Permalink"></a></h2><p>SymPy provides a means to substitute values in for the symbolic expressions. The specification requires an expression, a variable in the expression to substitute in for, and a new value. For example, this is one way to make a polynomial in a new variable:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x y
(x, y)

julia&gt; ex = x^2 + 2x + 1
x^2 + 2*x + 1

julia&gt; ex.subs(x, y)
y^2 + 2*y + 1
</code></pre><p>Substitution can also be numeric:</p><pre><code class="language-julia-repl hljs">julia&gt; ex.subs(x, 0)
1

</code></pre><p>The output has no free variables, but is still symbolic.</p><p>Expressions with more than one variable can have multiple substitutions, where each is expressed as a tuple:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x,y,z
(x, y, z)

julia&gt; ex = x + y + z
x + y + z

julia&gt; ex.subs([(x,1), (y, pi)])
z + 1 + pi</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The calling pattern for <code>subs</code> is different from a typical <code>Julia</code> function call. The <code>subs</code> call is <code>object.method(arguments...)</code> whereas a more &quot;<code>Julia</code>n&quot; function call is <code>method(objects, arguments...)</code>, as <code>Julia</code> offers multiple dispatch of methods. <code>SymPyPythonCall</code> uses the Python calling method, adding in <code>Julia</code>n style when appropriate for generic usage within <code>Julia</code>. <code>SymPyPythonCall</code> imports many generic functions from the underlying <code>sympy</code> module and specializes them on a symbolic first argument.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The SymPy documentation for many functions can be read from the terminal using <code>Base.Docs.getdoc(ex)</code>, as in <code>Base.Docs.getdoc(sin(x))</code>.</p></div></div><p>For <code>subs</code>, the simple substitution <code>ex.object(x,a)</code> is similar to simple function evaluation, so <code>Julia</code>&#39;s call notation will work. To specify the pairing off of <code>x</code> and <code>a</code>, the <code>=&gt;</code>  pairs notation is used.</p><p>This calling style will be equivalent to the last:</p><pre><code class="language-julia-repl hljs">julia&gt; ex(x=&gt;1, y=&gt;pi)
z + 1 + pi</code></pre><p>A straight call is also possble, where the order of the variables is determined by <code>free_symbols</code>. This is useful for expressions of a single variable, but being more explicit through the use of paired values is recommended.</p><h2 id="Conversion-from-symbolic-to-numeric"><a class="docs-heading-anchor" href="#Conversion-from-symbolic-to-numeric">Conversion from symbolic to numeric</a><a id="Conversion-from-symbolic-to-numeric-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-from-symbolic-to-numeric" title="Permalink"></a></h2><p>SymPy provides two identical means to convert a symbolic math expression to a number. One is <code>evalf</code>, the other <code>N</code>. Within <code>Julia</code> we decouple this, using <code>N</code> to also convert to a <code>Julian</code> value and <code>evalf</code> to leave the conversion as a symbolic object.  The <code>N</code> function converts symbolic integers, rationals, irrationals, and complex values, while attempting to find an appropriate <code>Julia</code> type for the value.</p><p>To see the difference, we use both on <code>PI</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; N(PI)  # converts to underlying pi irrational
π = 3.1415926535897...
</code></pre><p>Whereas, <code>evalf</code> will produce a symbolic numeric value:</p><pre><code class="language-julia-repl hljs">julia&gt; (PI).evalf()
3.14159265358979
</code></pre><p>The <code>evalf</code> call allows for a precision argument to be passed through the second argument. This is how 30 digits of <span>$\pi$</span> can be extracted:</p><pre><code class="language-julia-repl hljs">julia&gt; PI.evalf(30)
3.14159265358979323846264338328
</code></pre><p>This is a SymPy, symbolic number, not a <code>Julia</code> object. Composing with <code>N</code></p><pre><code class="language-julia-repl hljs">julia&gt; N(PI.evalf(30))
3.14159265358979311599796346854419
</code></pre><p>will produce a <code>Julia</code> number,</p><p>Explicit conversion via <code>convert(T, ex)</code> can also be done, and is necessary at times if <code>N</code> does not give the desired type.</p><h2 id="Algebraic-expressions"><a class="docs-heading-anchor" href="#Algebraic-expressions">Algebraic expressions</a><a id="Algebraic-expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Algebraic-expressions" title="Permalink"></a></h2><p><code>SymPyPythonCall</code> overloads many of <code>Julia</code>&#39;s functions to work with symbolic objects, such as seen above with <code>asin</code>. The usual mathematical operations such as <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code> etc. work through <code>Julia</code>&#39;s promotion mechanism, where numbers are promoted to symbolic objects, others dispatch internally to related SymPy functions.</p><p>In most all  cases, thinking about this distinction between numbers and symbolic numbers is unnecessary, as numeric values passed to <code>SymPyPythonCall</code> functions are typically promoted to symbolic expressions. This conversion will take math constants to their corresponding <code>SymPyPythonCall</code> counterpart, rational expressions to rational expressions, and floating point values to floating point values. However there are edge cases. An expression like <code>1//2 * pi * x</code> will differ from the seemingly identical  <code>1//2 * (pi * x)</code>. The former will produce a floating point value from <code>1//2 * pi</code> before being promoted to a symbolic instance. Using the symbolic value <code>PI</code> makes this expression work either way.</p><p>Most of <code>Julia</code>&#39;s <a href="http://julia.readthedocs.org/en/latest/manual/mathematical-operations/#elementary-functions">mathematical</a> functions are overloaded to work with symbolic expressions. <code>Julia</code>&#39;s generic definitions are used, as possible. This also introduces some edge cases. For example, <code>x^(-2)</code> will balk due to the negative, integer exponent, but either <code>x^(-2//1)</code> or <code>x^Sym(-2)</code> will work as expected, as the former call first dispatches to a generic defintion, but the latter two expressions do not.</p><p><code>SymPyPythonCall</code> makes it very easy to work with polynomial and rational expressions. First we create some variables:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x y z
(x, y, z)
</code></pre><h3 id="The-expand,-factor,-collect,-and-simplify-functions"><a class="docs-heading-anchor" href="#The-expand,-factor,-collect,-and-simplify-functions">The expand, factor, collect, and simplify functions</a><a id="The-expand,-factor,-collect,-and-simplify-functions-1"></a><a class="docs-heading-anchor-permalink" href="#The-expand,-factor,-collect,-and-simplify-functions" title="Permalink"></a></h3><p>A typical polynomial expression in a single variable can be written in two common ways, expanded or factored form. Using <code>factor</code> and <code>expand</code> can move between the two.</p><p>For example,</p><pre><code class="language-julia-repl hljs">julia&gt; p = x^2 + 3x + 2
x^2 + 3*x + 2

julia&gt; factor(p)
(x + 1)*(x + 2)</code></pre><p>Or</p><pre><code class="language-julia-repl hljs">julia&gt; expand(prod((x-i) for i in 1:5))
x^5 - 15*x^4 + 85*x^3 - 225*x^2 + 274*x - 120
</code></pre><p>The <code>factor</code> function factors over the rational numbers, so something like this with obvious factors is not finished:</p><pre><code class="language-julia-repl hljs">julia&gt; factor(x^2 - 2)
x^2 - 2
</code></pre><p>When expressions involve one or more variables, it can be convenient to be able to manipulate them. For example, if we define <code>q</code> by:</p><pre><code class="language-julia-repl hljs">julia&gt; q = x*y + x*y^2 + x^2*y + x
x^2*y + x*y^2 + x*y + x
</code></pre><p>Then we can collect the terms by the variable <code>x</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; collect(q, x)
x^2*y + x*(y^2 + y + 1)
</code></pre><p>or the variable <code>y</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; collect(q, y)
x*y^2 + x + y*(x^2 + x)
</code></pre><p>These are identical expressions, though viewed differently.</p><p>A more broad-brush approach is to let <code>SymPyPythonCall</code> simplify the values. In this case, the common value of <code>x</code> is factored out:</p><pre><code class="language-julia-repl hljs">julia&gt; simplify(q)
x*(x*y + y^2 + y + 1)
</code></pre><p>The <code>simplify</code> function attempts to apply the dozens of functions related to simplification that are part of SymPy. It is also possible to apply these functions one at a time, for example <code>sympy.trigsimp</code> does trigonometric simplifications.</p><p>The SymPy tutorial illustrates that <code>expand</code> can also result in simplifications through this example:</p><pre><code class="language-julia-repl hljs">julia&gt; expand((x + 1)*(x - 2) - (x - 1)*x)
-2
</code></pre><p>These methods are not restricted to polynomial expressions and will work with other expressions. For example, <code>factor</code> identifies the following as a factorable object in terms of the variable <code>exp(x)</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; factor(exp(2x) + 3exp(x) + 2)
(exp(x) + 1)*(exp(x) + 2)
</code></pre><h2 id="Rational-expressions:-apart,-together,-cancel"><a class="docs-heading-anchor" href="#Rational-expressions:-apart,-together,-cancel">Rational expressions: apart, together, cancel</a><a id="Rational-expressions:-apart,-together,-cancel-1"></a><a class="docs-heading-anchor-permalink" href="#Rational-expressions:-apart,-together,-cancel" title="Permalink"></a></h2><p>When working with rational expressions, SymPy does not do much simplification unless asked. For example this expression is not simplified:</p><pre><code class="language-julia-repl hljs">julia&gt; r = 1/x + 1/x^2
1/x + x^(-2)
</code></pre><p>To put the terms of <code>r</code> over a common denominator, the <code>together</code> function is available:</p><pre><code class="language-julia-repl hljs">julia&gt; together(r)
(x + 1)/x^2
</code></pre><p>The <code>apart</code> function does the reverse, creating a partial fraction decomposition from a ratio of polynomials:</p><pre><code class="language-julia-repl hljs">julia&gt; apart( (4x^3 + 21x^2 + 10x + 12) /  (x^4 + 5x^3 + 5x^2 + 4x))
(2*x - 1)/(x^2 + x + 1) - 1/(x + 4) + 3/x
</code></pre><p>Some times SymPy will cancel factors, as here:</p><pre><code class="language-julia-repl hljs">julia&gt; top = (x-1)*(x-2)*(x-3)
(x - 3)*(x - 2)*(x - 1)

julia&gt; bottom = (x-1)*(x-4)
(x - 4)*(x - 1)

julia&gt; top/bottom
(x - 3)*(x - 2)/(x - 4)
</code></pre><p>(This might make math faculty a bit upset, but it is in line with student thinking.)</p><p>However, with expanded terms, the common factor of <code>(x-1)</code> is not cancelled:</p><pre><code class="language-julia-repl hljs">julia&gt; r = expand(top) / expand(bottom)
(x^3 - 6*x^2 + 11*x - 6)/(x^2 - 5*x + 4)
</code></pre><p>The <code>cancel</code> function instructs SymPy to perform cancellations. It takes rational functions and puts them in a canonical <span>$p/q$</span> form with no common (rational) factors and leading terms which are integers:</p><pre><code class="language-julia-repl hljs">julia&gt; cancel(r)
(x^2 - 5*x + 6)/(x - 4)
</code></pre><h2 id="Powers"><a class="docs-heading-anchor" href="#Powers">Powers</a><a id="Powers-1"></a><a class="docs-heading-anchor-permalink" href="#Powers" title="Permalink"></a></h2><p>The SymPy <a href="http://docs.sympy.org/dev/tutorial/simplification.html#powers">tutorial</a> offers a thorough explanation on powers and which get simplified and under what conditions. Basically</p><ul><li><p class="math-container">\[x^a x^b = x^{a+b}\]</p><p>is always true. However</p></li><li><p class="math-container">\[x^a y^a=(xy)^a\]</p><p>is only true with assumptions, such as <span>$x,y \geq 0$</span> and <span>$a$</span> is real, but not in general. For example, <span>$x=y=-1$</span> and <span>$a=1/2$</span> has <span>$x^a \cdot y^a = i \cdot i =  -1$</span>, where as <span>$(xy)^a = 1$</span>.</p></li><li><p class="math-container">\[(x^a)^b = x^{ab}\]</p><p>is only true with assumptions. For example <span>$x=-1, a=2$</span>, and <span>$b=1/2$</span> gives <span>$(x^a)^b = 1^{1/2} = 1$</span>, whereas <span>$x^{ab} = -1^1 = -1$</span>.</p></li></ul><p>We see that with assumptions, the following expression does simplify to <span>$0$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x::nonnegatve y::nonnegative  a::real
(x, y, a)

julia&gt; simplify(x^a * y^a - (x*y)^a)
0
</code></pre><p>However, without assumptions this is not the case</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x,y,a
(x, y, a)

julia&gt; simplify(x^a * y^a - (x*y)^a)
x^a*y^a - (x*y)^a
</code></pre><p>The <code>simplify</code> function calls <code>powsimp</code> to simplify powers, as above. The <code>powsimp</code> function has the keyword argument <code>force=true</code> to force simplification even if assumptions are not specified:</p><pre><code class="language-julia-repl hljs">julia&gt; sympy.powsimp(x^a * y^a - (x*y)^a, force=true)
0
</code></pre><h2 id="Trigonometric-simplification"><a class="docs-heading-anchor" href="#Trigonometric-simplification">Trigonometric simplification</a><a id="Trigonometric-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Trigonometric-simplification" title="Permalink"></a></h2><p>For trigonometric expressions, <code>simplify</code> will use <code>trigsimp</code> to simplify:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms theta::real
(theta,)

julia&gt; p = cos(theta)^2 + sin(theta)^2
sin(theta)^2 + cos(theta)^2
</code></pre><p>Calling either <code>simplify</code> or <code>trigsimp</code> will apply the Pythagorean identity:</p><pre><code class="language-julia-repl hljs">julia&gt; simplify(p)
1
</code></pre><p>While often forgotten,  the <code>trigsimp</code> function is, of course,  aware of the double angle formulas:</p><pre><code class="language-julia-repl hljs">julia&gt; simplify(sin(2theta) - 2sin(theta)*cos(theta))
0
</code></pre><p>The <code>expand_trig</code> function will expand such expressions:</p><pre><code class="language-julia-repl hljs">julia&gt; expand_trig(sin(2theta))
2*sin(theta)*cos(theta)
</code></pre><h2 id="Coefficients"><a class="docs-heading-anchor" href="#Coefficients">Coefficients</a><a id="Coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Coefficients" title="Permalink"></a></h2><p>Returning to polynomials, there are a few functions to find various pieces of the polynomials. First we make a general quadratic polynomial:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms a,b,c,x
(a, b, c, x)

julia&gt; p = a*x^2 + b*x + c
a*x^2 + b*x + c
</code></pre><p>If given a polynomial, like <code>p</code>, there are different means to extract the coefficients:</p><ul><li><p>SymPy provides a <code>coeffs</code> method for <code>Poly</code> objects, but <code>p</code> must first be converted to one.</p></li><li><p>SymPy provides the <code>coeff</code> method for expressions, which allows extration of a coeffiecient for a given monomial</p></li></ul><p>The <code>ex.coeff(monom)</code> call will return the corresponding coefficient of the monomial:</p><pre><code class="language-julia-repl hljs">julia&gt; p.coeff(x^2) # a
a

julia&gt; p.coeff(x)   # b
b
</code></pre><p>The constant can be found through substitution:</p><pre><code class="language-julia-repl hljs">julia&gt; p(x=&gt;0)
c
</code></pre><p>Though one could use some trick like this to find all the coefficients, that is cumbersome, at best.</p><pre><code class="language-julia-repl hljs">julia&gt; vcat([p.coeff(x^i) for i in N(degree(p,gen=x)):-1:1], [p(x=&gt;0)])
3-element Vector{Sym}:
 a
 b
 c
</code></pre><p>SymPy has a function <code>coeffs</code>, but it is defined for polynomial types, so will fail on <code>p</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; try p.coeffs() catch err &quot;ERROR: KeyError: key `coeffs` not found&quot; end # wrap p.coeffs() for doctest of error
&quot;ERROR: KeyError: key `coeffs` not found&quot;</code></pre><p>Polynomials are a special class in SymPy and must be constructed. The <code>poly</code> constructor can be used. As there is more than one free variable in <code>p</code>, we specify the variable <code>x</code> below:</p><pre><code class="language-julia-repl hljs">julia&gt; q = sympy.poly(p, x)
Poly(a*x^2 + b*x + c, x, domain=&#39;ZZ[a,b,c]&#39;)

julia&gt; q.coeffs()
3-element Vector{Sym}:
 a
 b
 c
</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This is <code>sympy</code> not <code>SymPyPythonCall</code> qualifying the method call. Using <code>sympy.Poly</code> is not supported. The <code>Poly</code> constructor from SymPy is <em>not</em> a function, so is not exported when <code>SymPyCall</code> is loaded.</p></div></div><h2 id="Polynomial-roots:-solve,-real_roots,-polyroots,-nroots"><a class="docs-heading-anchor" href="#Polynomial-roots:-solve,-real_roots,-polyroots,-nroots">Polynomial roots: solve, real_roots, polyroots, nroots</a><a id="Polynomial-roots:-solve,-real_roots,-polyroots,-nroots-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-roots:-solve,-real_roots,-polyroots,-nroots" title="Permalink"></a></h2><p>SymPy provides functions to find the roots of a polynomial. In general, a polynomial with real coefficients of degree <span>$n$</span> will have <span>$n$</span> roots when multiplicities and complex roots are accounted for. The number of real roots is consequently between <span>$0$</span> and <span>$n$</span>.</p><p>For a <em>univariate</em> polynomial expression (a single variable), the real roots, when available, are returned by <code>real_roots</code>. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; real_roots(x^2 - 2)
2-element Vector{Sym}:
 -sqrt(2)
  sqrt(2)
</code></pre><p>Unlike <code>factor</code> – which only factors over rational factors – <code>real_roots</code> finds the two irrational roots here. It is well known (the <a href="http://en.wikipedia.org/wiki/Abel%E2%80%93Ruffini_theorem">Abel-Ruffini theorem</a>) that for degree 5 polynomials, or higher, it is not always possible to express the roots in terms of radicals. However, when the roots are rational SymPy can have success:</p><pre><code class="language-julia-repl hljs">julia&gt; p = (x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1)
x*(x - 3)^2*(x - 2)*(x - 1)*(x + 1)*(x^2 + x + 1)

julia&gt; real_roots(p)
6-element Vector{Sym}:
 -1
  0
  1
  2
  3
  3
</code></pre><p>In this example, the degree of <code>p</code> is 8, but only the 6 real roots returned, the double root of <span>$3$</span> is accounted for. The two complex roots of <code>x^2 + x+ 1</code> are not considered by this function. The complete set of distinct roots can be found with <code>solve</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; solve(p)
7-element Vector{Sym}:
                 -1
                  0
                  1
                  2
                  3
 -1/2 - sqrt(3)*I/2
 -1/2 + sqrt(3)*I/2
</code></pre><p>This finds the complex roots, but does not account for the double root. The <code>roots</code> function of SymPy does.</p><p>The output of calling <code>roots</code> will be a dictionary whose keys are the roots and values the multiplicity.</p><pre><code class="language-julia hljs">julia&gt; roots(p)
Dict{Any, Any} with 7 entries:
  -1                 =&gt; 1
  3                  =&gt; 2
  1                  =&gt; 1
  0                  =&gt; 1
  -1/2 - sqrt(3)*I/2 =&gt; 1
  2                  =&gt; 1
  -1/2 + sqrt(3)*I/2 =&gt; 1
</code></pre><p>When exact answers are not provided, the <code>roots</code> call is contentless:</p><pre><code class="language-julia-repl hljs">julia&gt; p = x^5 - x + 1
x^5 - x + 1

julia&gt; sympy.roots(p)
Dict{Any, Any}()
</code></pre><p>Calling <code>solve</code> seems to produce very little as well:</p><pre><code class="language-julia-repl hljs">julia&gt; rts = solve(p)
5-element Vector{Sym}:
 CRootOf(x^5 - x + 1, 0)
 CRootOf(x^5 - x + 1, 1)
 CRootOf(x^5 - x + 1, 2)
 CRootOf(x^5 - x + 1, 3)
 CRootOf(x^5 - x + 1, 4)
</code></pre><p>But in fact, <code>rts</code> contains lots of information. We can extract numeric values quite easily with <code>N</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; N.(rts)
5-element Vector{Number}:
                     -1.1673039782614187
 -0.18123244446987538 - 1.0839541013177107im
 -0.18123244446987538 + 1.0839541013177107im
   0.7648844336005847 - 0.35247154603172626im
   0.7648844336005847 + 0.35247154603172626im
</code></pre><p>These are numeric approximations to irrational values. For numeric approximations to polynomial roots, the <code>nroots</code> function is also provided. The answers are still symbolic:</p><pre><code class="language-julia-repl hljs">julia&gt; nroots(p)
5-element Vector{Sym}:
                       -1.16730397826142
 -0.181232444469875 - 1.08395410131771*I
 -0.181232444469875 + 1.08395410131771*I
 0.764884433600585 - 0.352471546031726*I
 0.764884433600585 + 0.352471546031726*I
</code></pre><h2 id="The-solve-function"><a class="docs-heading-anchor" href="#The-solve-function">The solve function</a><a id="The-solve-function-1"></a><a class="docs-heading-anchor-permalink" href="#The-solve-function" title="Permalink"></a></h2><p>The <code>solve</code> function is more general purpose than just finding roots of univariate polynomials. The function tries to solve for when an expression is 0, or a set of expressions are all 0.</p><p>For example, it can be used to solve when <span>$\cos(x) = \sin(x)$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; solve(cos(x) - sin(x))
1-element Vector{Sym}:
 pi/4
</code></pre><p>Though there are infinitely many correct solutions, these are within a certain range.</p><p>The <a href="http://docs.sympy.org/latest/modules/solvers/solveset.html">solveset</a> function appears in version 1.0 of SymPy and is an intended replacement for <code>solve</code>. Here we see it describes all solutions:</p><pre><code class="language-julia-repl hljs">julia&gt; u = solveset(cos(x) - sin(x))
Union(ImageSet(Lambda(_n, 2*_n*pi + 5*pi/4), Integers), ImageSet(Lambda(_n, 2*_n*pi + pi/4), Integers))
</code></pre><p>The output of <code>solveset</code> is a set, rather than a vector or dictionary.</p><pre><code class="language-julia-repl hljs">julia&gt; v = solveset(x^2 - 4)
Set{Sym} with 2 elements:
  2
  -2</code></pre><p>Solving within Sympy has limits. For example, there is no symbolic solution here:</p><pre><code class="language-julia-repl hljs">julia&gt; try  solve(cos(x) - x)  catch err &quot;error&quot; end # wrap command for doctest of error
&quot;error&quot;</code></pre><p>(And hence the error message generated.)</p><p>For such an equation, a numeric method would be needed, similar to the <code>Roots</code> package. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; nsolve(cos(x) - x, 1)
0.739085133215161
</code></pre><p>Though it can&#39;t solve everything, the <code>solve</code> function can also solve equations of a more general type. For example, here it is used to derive the quadratic equation:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms a::real, b::real, c::real
(a, b, c)

julia&gt; p = a*x^2 + b*x + c
a*x^2 + b*x + c

julia&gt; xs = solve(p, x);

julia&gt; [simplify(p(x =&gt; xᵢ)) for xᵢ ∈ xs]
2-element Vector{Sym}:
 0
 0
</code></pre><p>The extra argument <code>x</code> is passed to <code>solve</code> so that <code>solve</code> knows which variable to solve for.</p><p>The <code>solveset</code> function is similar:</p><pre><code class="language-julia-repl hljs">julia&gt; solveset(p, x); # Set with two elements</code></pre><p>If the <code>x</code> value is not given, <code>solveset</code> will error and  <code>solve</code> will try to find a solution over all the free variables:</p><pre><code class="language-julia-repl hljs">julia&gt; solve(p)
1-element Vector{Dict{Sym, Sym}}:
 Dict(a =&gt; (-b*x - c)/x^2)</code></pre><p>The output of <code>solveset</code> in Python is always a set, which may be finite or not. Finite sets are converted to <code>Set</code>s in <code>Julia</code>. Infinite sets have no natural counterpart and are not realized. Rather, they can be queried, as with <code>contains(haystack, needle)</code>. For example:</p><pre><code class="language-julia-repl hljs">julia&gt; u = solveset(sin(x) ≧ 0)  # [\geqq] or with u  = solveset(Ge(sin(x), 0))
ConditionSet(x, sin(x) &gt;= 0, Complexes)

julia&gt; contains(u, PI/2)
true

julia&gt; contains(u, 3PI/2)
false</code></pre><p>Infinite sets can have unions and intersections taken, but the SymPy methods must be called:</p><pre><code class="language-julia-repl hljs">julia&gt; v = solveset(cos(x) ≧ 0)
ConditionSet(x, cos(x) &gt;= 0, Complexes)

julia&gt; contains.((u, v, u.intersect(v), u.union(v)), 3PI/4)
(true, false, false, true)</code></pre><hr/><p>Systems of equations can be solved as well. We specify them within a vector of expressions, <code>[ex1, ex2, ..., exn]</code> where a found solution is one where all the expressions are 0. For example, to solve this linear system: <span>$2x + 3y = 6, 3x - 4y=12$</span>, we have:</p><pre><code class="language-julia-repl hljs">julia&gt; @syms x::real, y::real
(x, y)

julia&gt; exs = [2x+3y-6, 3x-4y-12]
2-element Vector{Sym}:
  2*x + 3*y - 6
 3*x - 4*y - 12</code></pre><pre><code class="language-julia-repl hljs">julia&gt; d = solve(exs); # Dict(x=&gt;60/17, y=&gt;-6/17)</code></pre><p>We can &quot;check our work&quot; by plugging into each equation. We take advantage of how the <code>subs</code> function allows us to pass in a dictionary:</p><pre><code class="language-julia-repl hljs">julia&gt; map(ex -&gt; ex.subs(d), exs)
2-element Vector{Sym}:
 0
 0
</code></pre><p>The more <code>Julia</code>n way to solve a linear  equation, like this   would be as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; A = Sym[2 3; 3  -4]; b = Sym[6, 12]
2-element Vector{Sym}:
  6
 12
julia&gt; A \ b
2-element Vector{Sym}:
 Fraction(60, 17)
 Fraction(-6, 17)
</code></pre><p>(Rather than use a generic  <code>lu</code> solver through <code>Julia</code> (which  proved slow for larger  systems),  the <code>\</code> operator utilizes  <code>solve</code> to perform this  computation.)</p><p>In the previous example, the system had two equations and two unknowns. When that is not the case, one can specify the variables to solve for as a vector. In this example, we find a quadratic polynomial that approximates <span>$\cos(x)$</span> near <span>$0$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; a,b,c,h = symbols(&quot;a,b,c,h&quot;, real=true)
4-element Vector{Sym}:
 a
 b
 c
 h

julia&gt; p = a*x^2 + b*x + c
a*x^2 + b*x + c

julia&gt; fn = cos;

julia&gt; exs = [fn(0*h)-p(x=&gt;0), fn(h)-p(x =&gt; h), fn(2h)-p(x =&gt; 2h)]
3-element Vector{Sym}:
                           1 - c
       -a*h^2 - b*h - c + cos(h)
 -4*a*h^2 - 2*b*h - c + cos(2*h)

julia&gt; d = solve(exs, (a,b,c));

julia&gt; d[a], d[b], d[c]
(-cos(h)/h^2 + cos(2*h)/(2*h^2) + 1/(2*h^2), 2*cos(h)/h - cos(2*h)/(2*h) - 3/(2*h), 1)
</code></pre><p>Again, a dictionary is returned, though we display its named elements individually. The polynomial itself can be found by substituting back in for <code>a</code>, <code>b</code>, and <code>c</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; quad_approx = p.subs(d)
x^2*(-cos(h)/h^2 + cos(2*h)/(2*h^2) + 1/(2*h^2)) + x*(2*cos(h)/h - cos(2*h)/(2*h) - 3/(2*h)) + 1
</code></pre><p>Taking the &quot;limit&quot; as <span>$h$</span> goes to 0 produces the answer <span>$1 - x^2/2$</span>, as  will be shown.</p><p>Finally for <code>solve</code>, we show one way to re-express the polynomial <span>$a_2x^2 + a_1x + a_0$</span> as <span>$b_2(x-c)^2 + b_1(x-c) + b_0$</span> using <code>solve</code> (and not, say, an expansion theorem.)</p><pre><code class="language-julia-repl hljs">julia&gt; n = 3
3

julia&gt; @syms x, c
(x, c)

julia&gt; @syms as[1:3]
(Sym[as₁, as₂, as₃],)

julia&gt; @syms bs[1:3]
(Sym[bs₁, bs₂, bs₃],)

julia&gt; p = sum([as[i+1]*x^i for i in 0:(n-1)]);

julia&gt; q = sum([bs[i+1]*(x-c)^i for i in 0:(n-1)]);

julia&gt; d = solve(p-q, bs);

julia&gt; [k =&gt; d[k] for k ∈ bs]
3-element Vector{Pair{Sym, Sym}}:
 bs₁ =&gt; as₁ + as₂*c + as₃*c^2
 bs₂ =&gt; as₂ + 2*as₃*c
 bs₃ =&gt; as₃
</code></pre><h3 id="Solving-using-logical-operators"><a class="docs-heading-anchor" href="#Solving-using-logical-operators">Solving using logical operators</a><a id="Solving-using-logical-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-using-logical-operators" title="Permalink"></a></h3><p>The <code>solve</code> function does not need to just solve <code>ex = 0</code>. There are other means to specify an equation. Ideally, it would be nice to say <code>ex1 == ex2</code>, but the interpretation of <code>==</code> is not for this. Rather, <code>SymPyPythonCall</code> introduces <code>Eq</code> for equality. So this expression</p><pre><code class="language-julia-repl hljs">julia&gt; solve(Eq(x, 1))
1-element Vector{Sym}:
 1
</code></pre><p>gives 1, as expected from solving <code>x == 1</code>.</p><p>In addition to <code>Eq</code>, there are <code>Lt</code>, <code>Le</code>, <code>Ge</code>, <code>Gt</code>. The Unicode operators (e.g., <code>\leq</code>  and not  <code>\leq</code>)  are not aliased to these, but there are alternatives <code>\ll[tab]</code>, <code>\leqq[tab]</code>, <code>\Equal[tab]</code>, <code>\geqq[tab]</code>, <code>\gg[tab]</code> and <code>\neg[tab]</code> to negate.</p><p>So, the above could have been written with the following nearly identical expression, though it is entered with <code>\Equal[tab]</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; solve(x ⩵ 1)
1-element Vector{Sym}:
 1
</code></pre><p>Here is an alternative way of asking a previous question on a pair of linear equations:</p><pre><code class="language-julia-repl hljs">julia&gt; x, y = symbols(&quot;x,y&quot;, real=true)
2-element Vector{Sym}:
 x
 y

julia&gt; exs = [2x+3y ⩵ 6, 3x-4y ⩵ 12]    ## Using \Equal[tab]
2-element Vector{Sym}:
  Eq(2*x + 3*y, 6)
 Eq(3*x - 4*y, 12)

julia&gt; d = solve(exs);

julia&gt; d[x], d[y]
(Fraction(60, 17), Fraction(-6, 17))
</code></pre><p>Here  is  one other way  to  express  the same</p><pre><code class="language-julia-repl hljs">julia&gt; Eq.( [2x+3y,3x-4y], [6,12]) |&gt;  solve == d
true</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../docstrings/">« Docstrings</a><a class="docs-footer-nextpage" href="../overview/">Basic overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.0 on <span class="colophon-date" title="Thursday 28 September 2023 15:55">Thursday 28 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
