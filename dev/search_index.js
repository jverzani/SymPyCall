var documenterSearchIndex = {"docs":
[{"location":"introduction/#A-SymPyPythonCall-introduction","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"note: SymPyPythonCall\nSymPyPythonCall.jl is like the SymPy.jl package in that it allows access to the underlying SymPy library for Python from within Julia.Whereas SymPy.jl uses the PyCall package, SymPyPythonCall uses the PythonCall package to provide the bridge between Julia and Python.Though the two packages work similarly, there are a few differences:@vars of SymPy is not provided; use the more powerful @syms macro only\nBase.show isn't currently using pretty printing\nSets are handled differently, with finite sets converted to Julia Sets.\nCurrently Q is not exported. (only the slant italic Q is currently)\nMatrix support may not be complete.\nsympy.poly not sympy.Poly\nThe form limit(ex, x, c) is not provided; use limit(ex, x=>c) or sympy.limit\nno new special functions exported, just the ones in SpecialFunctions.jl","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"This document provides an introduction to using SymPy within Julia. It owes an enormous debt to the tutorial for using SymPy within Python which may be found here. The overall structure and many examples are taken from that work, with adjustments and additions to illustrate the differences due to using SymPy within Julia.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"After installing SymPyPythonCall we must first load it into Julia with the standard command using:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"using SymPyPythonCall\nsympy.init_printing(use_latex=true)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> using SymPyPythonCall","category":"page"},{"location":"introduction/#Symbols","page":"A SymPyPythonCall introduction","title":"Symbols","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"At the core of SymPy is the introduction of symbolic variables that differ quite a bit from Julia's variables. Symbolic variables do not immediately evaluate to a value, rather the \"symbolicness\" propagates when interacted with. To keep things manageable, SymPy does some simplifications along the way.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Symbolic expressions are primarily of the Sym type and can be constructed in the standard way:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> x = Sym(\"x\")\nx","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"This creates a symbolic object x, which can be manipulated through further function calls.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"There is the @syms macro that makes creating multiple variables a bit less typing, as it creates variables in the local scope – no assignment is necessary. Compare these similar ways to create symbolic variables:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms a b c\n(a, b, c)\n\njulia> a,b,c = Sym(\"a,b,c\")\n3-element Vector{Sym}:\n a\n b\n c","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Here are two ways to make related variables:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms xs[1:5]\n(Sym[xs₁, xs₂, xs₃, xs₄, xs₅],)\n\njulia> ys = [Sym(\"y$i\") for i in 1:5]\n5-element Vector{Sym}:\n y1\n y2\n y3\n y4\n y5","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The former much more succinct, but the latter pattern of use when the number of terms is a variable.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The @syms macro is recommended, and will be modeled in the following, as it makes the specification of assumptions and symbolic functions more natural.","category":"page"},{"location":"introduction/#Assumptions","page":"A SymPyPythonCall introduction","title":"Assumptions","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Finally, there is the symbols constructor for producing symbolic objects. With symbols (and with @syms) it is possible to pass assumptions onto the variables. A list of possible assumptions is here. Some examples are:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> u = symbols(\"u\")\nu\n\njulia> x = symbols(\"x\", real=true)\nx\n\njulia> y1, y2 = symbols(\"y1, y2\", positive=true)\n2-element Vector{Sym}:\n y1\n y2\n\njulia> alpha = symbols(\"alpha\", integer=true, positive=true)\nalpha\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"As seen, the symbols function can be used to make one or more variables with zero, one or more assumptions.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"We jump ahead for a second to illustrate, but here we see that solve will respect these assumptions, by failing to find solutions to these equations:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> solve(x^2 + 1)   # ±i are not real\nSym[]\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> solve(y1 + 1)    # -1 is not positive\nSym[]\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The @syms macro allows annotations, akin to type annotations, to specify assumptions on new variables:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms u1::positive u2::positive\n(u1, u2)\n\njulia> solve(u1 + u2)  # empty, though solving u1 - u2 is not.\nSym[]","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Additionally you can rename arguments using pair notation:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms a1=>\"α₁\" a2=>\"α₂\"\n(α₁, α₂)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"In this example, the Julia variables a1 and a2 are defined to store SymPy symbols with the \"pretty\" names α₁ and α₂ respectively.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"As can be seen, there are several ways to create symbolic values, but the recommended way is to use @syms. One caveat is that one can't use Sym to create a variable from a function name in Base.","category":"page"},{"location":"introduction/#Special-constants","page":"A SymPyPythonCall introduction","title":"Special constants","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Julia has its math constants, like pi and e, SymPy as well. A few of these have Julia counterparts provided by SymPyPythonCall. For example, these two constants are defined (where oo is for infinity):","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> PI,  oo\n(pi, oo)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Numeric values themselves can be symbolic. This example shows the difference. The first asin call dispatches to Julia's asin function, the second to SymPy's:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> [asin(1), asin(Sym(1))]\n2-element Vector{Sym}:\n 1.5707963267948966\n               pi/2\n","category":"page"},{"location":"introduction/#Substitution","page":"A SymPyPythonCall introduction","title":"Substitution","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"SymPy provides a means to substitute values in for the symbolic expressions. The specification requires an expression, a variable in the expression to substitute in for, and a new value. For example, this is one way to make a polynomial in a new variable:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms x y\n(x, y)\n\njulia> ex = x^2 + 2x + 1\nx^2 + 2*x + 1\n\njulia> ex.subs(x, y)\ny^2 + 2*y + 1\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Substitution can also be numeric:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> ex.subs(x, 0)\n1\n\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The output has no free variables, but is still symbolic.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Expressions with more than one variable can have multiple substitutions, where each is expressed as a tuple:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms x,y,z\n(x, y, z)\n\njulia> ex = x + y + z\nx + y + z\n\njulia> ex.subs([(x,1), (y, pi)])\nz + 1 + pi","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"note: Note\nThe calling pattern for subs is different from a typical Julia function call. The subs call is object.method(arguments...) whereas a more \"Julian\" function call is method(objects, arguments...), as Julia offers multiple dispatch of methods. SymPyPythonCall uses the Python calling method, adding in Julian style when appropriate for generic usage within Julia. SymPyPythonCall imports many generic functions from the underlying sympy module and specializes them on a symbolic first argument.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"note: Note\nThe SymPy documentation for many functions can be read from the terminal using Base.Docs.getdoc(ex), as in Base.Docs.getdoc(sin(x)).","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"For subs, the simple substitution ex.object(x,a) is similar to simple function evaluation, so Julia's call notation will work. To specify the pairing off of x and a, the =>  pairs notation is used.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"This calling style will be equivalent to the last:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> ex(x=>1, y=>pi)\nz + 1 + pi","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"A straight call is also possble, where the order of the variables is determined by free_symbols. This is useful for expressions of a single variable, but being more explicit through the use of paired values is recommended.","category":"page"},{"location":"introduction/#Conversion-from-symbolic-to-numeric","page":"A SymPyPythonCall introduction","title":"Conversion from symbolic to numeric","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"SymPy provides two identical means to convert a symbolic math expression to a number. One is evalf, the other N. Within Julia we decouple this, using N to also convert to a Julian value and evalf to leave the conversion as a symbolic object.  The N function converts symbolic integers, rationals, irrationals, and complex values, while attempting to find an appropriate Julia type for the value.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"To see the difference, we use both on PI:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> N(PI)  # converts to underlying pi irrational\nπ = 3.1415926535897...\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Whereas, evalf will produce a symbolic numeric value:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> (PI).evalf()\n3.14159265358979\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The evalf call allows for a precision argument to be passed through the second argument. This is how 30 digits of pi can be extracted:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> PI.evalf(30)\n3.14159265358979323846264338328\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"This is a SymPy, symbolic number, not a Julia object. Composing with N","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> N(PI.evalf(30))\n3.14159265358979311599796346854419\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"will produce a Julia number,","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Explicit conversion via convert(T, ex) can also be done, and is necessary at times if N does not give the desired type.","category":"page"},{"location":"introduction/#Algebraic-expressions","page":"A SymPyPythonCall introduction","title":"Algebraic expressions","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"SymPyPythonCall overloads many of Julia's functions to work with symbolic objects, such as seen above with asin. The usual mathematical operations such as +, *, -, / etc. work through Julia's promotion mechanism, where numbers are promoted to symbolic objects, others dispatch internally to related SymPy functions.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"In most all  cases, thinking about this distinction between numbers and symbolic numbers is unnecessary, as numeric values passed to SymPyPythonCall functions are typically promoted to symbolic expressions. This conversion will take math constants to their corresponding SymPyPythonCall counterpart, rational expressions to rational expressions, and floating point values to floating point values. However there are edge cases. An expression like 1//2 * pi * x will differ from the seemingly identical  1//2 * (pi * x). The former will produce a floating point value from 1//2 * pi before being promoted to a symbolic instance. Using the symbolic value PI makes this expression work either way.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Most of Julia's mathematical functions are overloaded to work with symbolic expressions. Julia's generic definitions are used, as possible. This also introduces some edge cases. For example, x^(-2) will balk due to the negative, integer exponent, but either x^(-2//1) or x^Sym(-2) will work as expected, as the former call first dispatches to a generic defintion, but the latter two expressions do not.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"SymPyPythonCall makes it very easy to work with polynomial and rational expressions. First we create some variables:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms x y z\n(x, y, z)\n","category":"page"},{"location":"introduction/#The-expand,-factor,-collect,-and-simplify-functions","page":"A SymPyPythonCall introduction","title":"The expand, factor, collect, and simplify functions","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"A typical polynomial expression in a single variable can be written in two common ways, expanded or factored form. Using factor and expand can move between the two.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"For example,","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> p = x^2 + 3x + 2\nx^2 + 3*x + 2\n\njulia> factor(p)\n(x + 1)*(x + 2)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Or","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> expand(prod((x-i) for i in 1:5))\nx^5 - 15*x^4 + 85*x^3 - 225*x^2 + 274*x - 120\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The factor function factors over the rational numbers, so something like this with obvious factors is not finished:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> factor(x^2 - 2)\nx^2 - 2\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"When expressions involve one or more variables, it can be convenient to be able to manipulate them. For example, if we define q by:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> q = x*y + x*y^2 + x^2*y + x\nx^2*y + x*y^2 + x*y + x\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Then we can collect the terms by the variable x:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> collect(q, x)\nx^2*y + x*(y^2 + y + 1)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"or the variable y:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> collect(q, y)\nx*y^2 + x + y*(x^2 + x)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"These are identical expressions, though viewed differently.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"A more broad-brush approach is to let SymPyPythonCall simplify the values. In this case, the common value of x is factored out:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> simplify(q)\nx*(x*y + y^2 + y + 1)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The simplify function attempts to apply the dozens of functions related to simplification that are part of SymPy. It is also possible to apply these functions one at a time, for example sympy.trigsimp does trigonometric simplifications.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The SymPy tutorial illustrates that expand can also result in simplifications through this example:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> expand((x + 1)*(x - 2) - (x - 1)*x)\n-2\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"These methods are not restricted to polynomial expressions and will work with other expressions. For example, factor identifies the following as a factorable object in terms of the variable exp(x):","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> factor(exp(2x) + 3exp(x) + 2)\n(exp(x) + 1)*(exp(x) + 2)\n","category":"page"},{"location":"introduction/#Rational-expressions:-apart,-together,-cancel","page":"A SymPyPythonCall introduction","title":"Rational expressions: apart, together, cancel","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"When working with rational expressions, SymPy does not do much simplification unless asked. For example this expression is not simplified:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> r = 1/x + 1/x^2\n1/x + x^(-2)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"To put the terms of r over a common denominator, the together function is available:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> together(r)\n(x + 1)/x^2\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The apart function does the reverse, creating a partial fraction decomposition from a ratio of polynomials:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> apart( (4x^3 + 21x^2 + 10x + 12) /  (x^4 + 5x^3 + 5x^2 + 4x))\n(2*x - 1)/(x^2 + x + 1) - 1/(x + 4) + 3/x\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Some times SymPy will cancel factors, as here:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> top = (x-1)*(x-2)*(x-3)\n(x - 3)*(x - 2)*(x - 1)\n\njulia> bottom = (x-1)*(x-4)\n(x - 4)*(x - 1)\n\njulia> top/bottom\n(x - 3)*(x - 2)/(x - 4)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"(This might make math faculty a bit upset, but it is in line with student thinking.)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"However, with expanded terms, the common factor of (x-1) is not cancelled:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> r = expand(top) / expand(bottom)\n(x^3 - 6*x^2 + 11*x - 6)/(x^2 - 5*x + 4)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The cancel function instructs SymPy to perform cancellations. It takes rational functions and puts them in a canonical pq form with no common (rational) factors and leading terms which are integers:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> cancel(r)\n(x^2 - 5*x + 6)/(x - 4)\n","category":"page"},{"location":"introduction/#Powers","page":"A SymPyPythonCall introduction","title":"Powers","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The SymPy tutorial offers a thorough explanation on powers and which get simplified and under what conditions. Basically","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"x^a x^b = x^a+b\nis always true. However\nx^a y^a=(xy)^a\nis only true with assumptions, such as xy geq 0 and a is real, but not in general. For example, x=y=-1 and a=12 has x^a cdot y^a = i cdot i =  -1, where as (xy)^a = 1.\n(x^a)^b = x^ab\nis only true with assumptions. For example x=-1 a=2, and b=12 gives (x^a)^b = 1^12 = 1, whereas x^ab = -1^1 = -1.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"We see that with assumptions, the following expression does simplify to 0:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms x::nonnegatve y::nonnegative  a::real\n(x, y, a)\n\njulia> simplify(x^a * y^a - (x*y)^a)\n0\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"However, without assumptions this is not the case","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms x,y,a\n(x, y, a)\n\njulia> simplify(x^a * y^a - (x*y)^a)\nx^a*y^a - (x*y)^a\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The simplify function calls powsimp to simplify powers, as above. The powsimp function has the keyword argument force=true to force simplification even if assumptions are not specified:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> sympy.powsimp(x^a * y^a - (x*y)^a, force=true)\n0\n","category":"page"},{"location":"introduction/#Trigonometric-simplification","page":"A SymPyPythonCall introduction","title":"Trigonometric simplification","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"For trigonometric expressions, simplify will use trigsimp to simplify:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms theta::real\n(theta,)\n\njulia> p = cos(theta)^2 + sin(theta)^2\nsin(theta)^2 + cos(theta)^2\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Calling either simplify or trigsimp will apply the Pythagorean identity:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> simplify(p)\n1\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"While often forgotten,  the trigsimp function is, of course,  aware of the double angle formulas:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> simplify(sin(2theta) - 2sin(theta)*cos(theta))\n0\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The expand_trig function will expand such expressions:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> expand_trig(sin(2theta))\n2*sin(theta)*cos(theta)\n","category":"page"},{"location":"introduction/#Coefficients","page":"A SymPyPythonCall introduction","title":"Coefficients","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Returning to polynomials, there are a few functions to find various pieces of the polynomials. First we make a general quadratic polynomial:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms a,b,c,x\n(a, b, c, x)\n\njulia> p = a*x^2 + b*x + c\na*x^2 + b*x + c\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"If given a polynomial, like p, there are different means to extract the coefficients:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"SymPy provides a coeffs method for Poly objects, but p must first be converted to one.\nSymPy provides the coeff method for expressions, which allows extration of a coeffiecient for a given monomial","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The ex.coeff(monom) call will return the corresponding coefficient of the monomial:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> p.coeff(x^2) # a\na\n\njulia> p.coeff(x)   # b\nb\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The constant can be found through substitution:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> p(x=>0)\nc\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Though one could use some trick like this to find all the coefficients, that is cumbersome, at best.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> vcat([p.coeff(x^i) for i in N(degree(p,gen=x)):-1:1], [p(x=>0)])\n3-element Vector{Sym}:\n a\n b\n c\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"SymPy has a function coeffs, but it is defined for polynomial types, so will fail on p:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> try p.coeffs() catch err \"ERROR: KeyError: key `coeffs` not found\" end # wrap p.coeffs() for doctest of error\n\"ERROR: KeyError: key `coeffs` not found\"","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Polynomials are a special class in SymPy and must be constructed. The poly constructor can be used. As there is more than one free variable in p, we specify the variable x below:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> q = sympy.poly(p, x)\nPoly(a*x^2 + b*x + c, x, domain='ZZ[a,b,c]')\n\njulia> q.coeffs()\n3-element Vector{Sym}:\n a\n b\n c\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"note: Note\nThis is sympy not SymPyPythonCall qualifying the method call. Using sympy.Poly is not supported. The Poly constructor from SymPy is not a function, so is not exported when SymPyCall is loaded.","category":"page"},{"location":"introduction/#Polynomial-roots:-solve,-real_roots,-polyroots,-nroots","page":"A SymPyPythonCall introduction","title":"Polynomial roots: solve, real_roots, polyroots, nroots","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"SymPy provides functions to find the roots of a polynomial. In general, a polynomial with real coefficients of degree n will have n roots when multiplicities and complex roots are accounted for. The number of real roots is consequently between 0 and n.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"For a univariate polynomial expression (a single variable), the real roots, when available, are returned by real_roots. For example,","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> real_roots(x^2 - 2)\n2-element Vector{Sym}:\n -sqrt(2)\n  sqrt(2)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Unlike factor – which only factors over rational factors – real_roots finds the two irrational roots here. It is well known (the Abel-Ruffini theorem) that for degree 5 polynomials, or higher, it is not always possible to express the roots in terms of radicals. However, when the roots are rational SymPy can have success:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> p = (x-3)^2*(x-2)*(x-1)*x*(x+1)*(x^2 + x + 1)\nx*(x - 3)^2*(x - 2)*(x - 1)*(x + 1)*(x^2 + x + 1)\n\njulia> real_roots(p)\n6-element Vector{Sym}:\n -1\n  0\n  1\n  2\n  3\n  3\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"In this example, the degree of p is 8, but only the 6 real roots returned, the double root of 3 is accounted for. The two complex roots of x^2 + x+ 1 are not considered by this function. The complete set of distinct roots can be found with solve:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> solve(p)\n7-element Vector{Sym}:\n                 -1\n                  0\n                  1\n                  2\n                  3\n -1/2 - sqrt(3)*I/2\n -1/2 + sqrt(3)*I/2\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"This finds the complex roots, but does not account for the double root. The roots function of SymPy does.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The output of calling roots will be a dictionary whose keys are the roots and values the multiplicity.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> roots(p)\nDict{Any, Any} with 7 entries:\n  -1                 => 1\n  3                  => 2\n  1                  => 1\n  0                  => 1\n  -1/2 - sqrt(3)*I/2 => 1\n  2                  => 1\n  -1/2 + sqrt(3)*I/2 => 1\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"When exact answers are not provided, the roots call is contentless:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> p = x^5 - x + 1\nx^5 - x + 1\n\njulia> sympy.roots(p)\nDict{Any, Any}()\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Calling solve seems to produce very little as well:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> rts = solve(p)\n5-element Vector{Sym}:\n CRootOf(x^5 - x + 1, 0)\n CRootOf(x^5 - x + 1, 1)\n CRootOf(x^5 - x + 1, 2)\n CRootOf(x^5 - x + 1, 3)\n CRootOf(x^5 - x + 1, 4)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"But in fact, rts contains lots of information. We can extract numeric values quite easily with N:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> N.(rts)\n5-element Vector{Number}:\n                     -1.1673039782614187\n -0.18123244446987538 - 1.0839541013177107im\n -0.18123244446987538 + 1.0839541013177107im\n   0.7648844336005847 - 0.35247154603172626im\n   0.7648844336005847 + 0.35247154603172626im\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"These are numeric approximations to irrational values. For numeric approximations to polynomial roots, the nroots function is also provided. The answers are still symbolic:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> nroots(p)\n5-element Vector{Sym}:\n                       -1.16730397826142\n -0.181232444469875 - 1.08395410131771*I\n -0.181232444469875 + 1.08395410131771*I\n 0.764884433600585 - 0.352471546031726*I\n 0.764884433600585 + 0.352471546031726*I\n","category":"page"},{"location":"introduction/#The-solve-function","page":"A SymPyPythonCall introduction","title":"The solve function","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The solve function is more general purpose than just finding roots of univariate polynomials. The function tries to solve for when an expression is 0, or a set of expressions are all 0.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"For example, it can be used to solve when cos(x) = sin(x):","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> solve(cos(x) - sin(x))\n1-element Vector{Sym}:\n pi/4\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Though there are infinitely many correct solutions, these are within a certain range.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The solveset function appears in version 1.0 of SymPy and is an intended replacement for solve. Here we see it describes all solutions:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> u = solveset(cos(x) - sin(x))\nUnion(ImageSet(Lambda(_n, 2*_n*pi + 5*pi/4), Integers), ImageSet(Lambda(_n, 2*_n*pi + pi/4), Integers))\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The output of solveset is a set, rather than a vector or dictionary.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> v = solveset(x^2 - 4)\nSet{Sym} with 2 elements:\n  2\n  -2","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Solving within Sympy has limits. For example, there is no symbolic solution here:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> try  solve(cos(x) - x)  catch err \"error\" end # wrap command for doctest of error\n\"error\"","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"(And hence the error message generated.)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"For such an equation, a numeric method would be needed, similar to the Roots package. For example:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> nsolve(cos(x) - x, 1)\n0.739085133215161\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Though it can't solve everything, the solve function can also solve equations of a more general type. For example, here it is used to derive the quadratic equation:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms a::real, b::real, c::real\n(a, b, c)\n\njulia> p = a*x^2 + b*x + c\na*x^2 + b*x + c\n\njulia> xs = solve(p, x);\n\njulia> [simplify(p(x => xᵢ)) for xᵢ ∈ xs]\n2-element Vector{Sym}:\n 0\n 0\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The extra argument x is passed to solve so that solve knows which variable to solve for.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The solveset function is similar:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> solveset(p, x); # Set with two elements","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"If the x value is not given, solveset will error and  solve will try to find a solution over all the free variables:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> solve(p)\n1-element Vector{Dict{Sym, Sym}}:\n Dict(a => (-b*x - c)/x^2)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The output of solveset in Python is always a set, which may be finite or not. Finite sets are converted to Sets in Julia. Infinite sets have no natural counterpart and are not realized. Rather, they can be queried, as with contains(haystack, needle). For example:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> u = solveset(sin(x) ≧ 0)  # [\\geqq] or with u  = solveset(Ge(sin(x), 0))\nConditionSet(x, sin(x) >= 0, Complexes)\n\njulia> contains(u, PI/2)\ntrue\n\njulia> contains(u, 3PI/2)\nfalse","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Infinite sets can have unions and intersections taken, but the SymPy methods must be called:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> v = solveset(cos(x) ≧ 0)\nConditionSet(x, cos(x) >= 0, Complexes)\n\njulia> contains.((u, v, u.intersect(v), u.union(v)), 3PI/4)\n(true, false, false, true)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Systems of equations can be solved as well. We specify them within a vector of expressions, [ex1, ex2, ..., exn] where a found solution is one where all the expressions are 0. For example, to solve this linear system: 2x + 3y = 6 3x - 4y=12, we have:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> @syms x::real, y::real\n(x, y)\n\njulia> exs = [2x+3y-6, 3x-4y-12]\n2-element Vector{Sym}:\n  2*x + 3*y - 6\n 3*x - 4*y - 12","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> d = solve(exs); # Dict(x=>60/17, y=>-6/17)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"We can \"check our work\" by plugging into each equation. We take advantage of how the subs function allows us to pass in a dictionary:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> map(ex -> ex.subs(d), exs)\n2-element Vector{Sym}:\n 0\n 0\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The more Julian way to solve a linear  equation, like this   would be as follows:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> A = Sym[2 3; 3  -4]; b = Sym[6, 12]\n2-element Vector{Sym}:\n  6\n 12\njulia> A \\ b\n2-element Vector{Sym}:\n Fraction(60, 17)\n Fraction(-6, 17)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"(Rather than use a generic  lu solver through Julia (which  proved slow for larger  systems),  the \\ operator utilizes  solve to perform this  computation.)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"In the previous example, the system had two equations and two unknowns. When that is not the case, one can specify the variables to solve for as a vector. In this example, we find a quadratic polynomial that approximates cos(x) near 0:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> a,b,c,h = symbols(\"a,b,c,h\", real=true)\n4-element Vector{Sym}:\n a\n b\n c\n h\n\njulia> p = a*x^2 + b*x + c\na*x^2 + b*x + c\n\njulia> fn = cos;\n\njulia> exs = [fn(0*h)-p(x=>0), fn(h)-p(x => h), fn(2h)-p(x => 2h)]\n3-element Vector{Sym}:\n                           1 - c\n       -a*h^2 - b*h - c + cos(h)\n -4*a*h^2 - 2*b*h - c + cos(2*h)\n\njulia> d = solve(exs, (a,b,c));\n\njulia> d[a], d[b], d[c]\n(-cos(h)/h^2 + cos(2*h)/(2*h^2) + 1/(2*h^2), 2*cos(h)/h - cos(2*h)/(2*h) - 3/(2*h), 1)\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Again, a dictionary is returned, though we display its named elements individually. The polynomial itself can be found by substituting back in for a, b, and c:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> quad_approx = p.subs(d)\nx^2*(-cos(h)/h^2 + cos(2*h)/(2*h^2) + 1/(2*h^2)) + x*(2*cos(h)/h - cos(2*h)/(2*h) - 3/(2*h)) + 1\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Taking the \"limit\" as h goes to 0 produces the answer 1 - x^22, as  will be shown.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Finally for solve, we show one way to re-express the polynomial a_2x^2 + a_1x + a_0 as b_2(x-c)^2 + b_1(x-c) + b_0 using solve (and not, say, an expansion theorem.)","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> n = 3\n3\n\njulia> @syms x, c\n(x, c)\n\njulia> @syms as[1:3]\n(Sym[as₁, as₂, as₃],)\n\njulia> @syms bs[1:3]\n(Sym[bs₁, bs₂, bs₃],)\n\njulia> p = sum([as[i+1]*x^i for i in 0:(n-1)]);\n\njulia> q = sum([bs[i+1]*(x-c)^i for i in 0:(n-1)]);\n\njulia> d = solve(p-q, bs);\n\njulia> [k => d[k] for k ∈ bs]\n3-element Vector{Pair{Sym, Sym}}:\n bs₁ => as₁ + as₂*c + as₃*c^2\n bs₂ => as₂ + 2*as₃*c\n bs₃ => as₃\n","category":"page"},{"location":"introduction/#Solving-using-logical-operators","page":"A SymPyPythonCall introduction","title":"Solving using logical operators","text":"","category":"section"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"The solve function does not need to just solve ex = 0. There are other means to specify an equation. Ideally, it would be nice to say ex1 == ex2, but the interpretation of == is not for this. Rather, SymPyPythonCall introduces Eq for equality. So this expression","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> solve(Eq(x, 1))\n1-element Vector{Sym}:\n 1\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"gives 1, as expected from solving x == 1.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"In addition to Eq, there are Lt, Le, Ge, Gt. The Unicode operators (e.g., \\leq  and not  \\leq)  are not aliased to these, but there are alternatives \\ll[tab], \\leqq[tab], \\Equal[tab], \\geqq[tab], \\gg[tab] and \\neg[tab] to negate.","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"So, the above could have been written with the following nearly identical expression, though it is entered with \\Equal[tab]:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> solve(x ⩵ 1)\n1-element Vector{Sym}:\n 1\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Here is an alternative way of asking a previous question on a pair of linear equations:","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> x, y = symbols(\"x,y\", real=true)\n2-element Vector{Sym}:\n x\n y\n\njulia> exs = [2x+3y ⩵ 6, 3x-4y ⩵ 12]    ## Using \\Equal[tab]\n2-element Vector{Sym}:\n  Eq(2*x + 3*y, 6)\n Eq(3*x - 4*y, 12)\n\njulia> d = solve(exs);\n\njulia> d[x], d[y]\n(Fraction(60, 17), Fraction(-6, 17))\n","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"Here  is  one other way  to  express  the same","category":"page"},{"location":"introduction/","page":"A SymPyPythonCall introduction","title":"A SymPyPythonCall introduction","text":"julia> Eq.( [2x+3y,3x-4y], [6,12]) |>  solve == d\ntrue","category":"page"},{"location":"overview/#Basic-overview","page":"Basic overview","title":"Basic overview","text":"","category":"section"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"An interface between Julia and SymPy requires a few things. PythonCall can call into an underlying sympy library, for example","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> import PythonCall\n\njulia> const _sympy_ = PythonCall.pynew()\nPython: NULL\n\njulia> PythonCall.pycopy!(_sympy_, PythonCall.pyimport(\"sympy\"));","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The _sympy_ object holds references to the underlying sympy library. For example, we can create a symbolic variable and call the sin function on it as follows:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> x = _sympy_.symbols(\"x\")\nPython: x\n\njulia> _sympy_.sin(x)\nPython: sin(x)\n\njulia> x.is_commutative\nPython: True\n\njulia> typeof(x)\nPythonCall.Py","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The PythonCall package provides some basic operations for Py objects, such as basic math operations:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> x + x\nPython: 2*x\n\njulia> x * x\nPython: x**2\n\njulia> x ^ x\nPython: x**x","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"SymPyPythonCall wraps the Py objects in its Sym class to provide a means to dispatch familiar Julia generics:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> using SymPyPythonCall\n","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> x = symbols(\"x\")\nx\n\njulia> simplify(2sin(x)*cos(x))\nsin(2*x)","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The package also provides methods for some sympy methods, such as simplify above. To make this work, there needs to be a means to take Sym objects to the Py counterparts and to take Py objects to Sym. As these conversions may be type dependent two operators (with the unicode equivalents ↓ and  ↑) are used internally to allow the definition along these lines:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"simplify(x::Sym, args...; kwargs...) = ↑(sympy.simplify(↓(x), ↓(args)...; ↓(kwargs)...))","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The expand_log function is not wrapped as such, but can be called from the sympy object exported by SymPyPythonCall:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> @syms x::real\n(x,)\n\njulia> simplify(log(2x))\nlog(2*x)\n\njulia> sympy.expand_log(log(2x))\nlog(x) + log(2)","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"Methods of sympy are also called using the conversion operators above.","category":"page"},{"location":"overview/#Using-other-SymPy-modules","page":"Basic overview","title":"Using other SymPy modules","text":"","category":"section"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"We follow part of the SymPy docs to see how to access one of the numerous external modules of sympy beyond those exposed immediately by SymPy.","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> import SymPyPythonCall.PythonCall: pyimport\n\njulia> stats = pyimport(\"sympy.stats\");","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The stats module holds several probability functions, similar to the Distributions package of Julia. This set of commands creates a normally distributed random variable, X, with symbolic parameters:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> @syms μ, σ::positive;\n\njulia> X = stats.Normal(\"X\", μ, σ)\nPython: X\n\njulia> stats.E(X)\nPython: μ\n\njulia> stats.E(X^2)\nPython: μ**2 + σ**2\n\njulia> stats.variance(X)\nPython: σ**2","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The one thing to note is the method calls return Py objects, as there is no intercepting of the method calls done the way there is for the sympy module. The Sym command can be used to wrap the output:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> stats.variance(X) |> Sym\nσ^2","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The methods in the stats module are qualified with the module name above.","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"Next we see that statements like P(X  mu) can be answered specifying the inequality using sympy.Gt in the following:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> stats.P(sympy.Gt(X, μ))\nPython: 1/2","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"A typical calculation for the normal distribution is the area one or more standard deviations larger than the mean:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> stats.P(sympy.Gt(X, μ + 1σ)) |> Sym\nsqrt(2)*(-sqrt(2)*pi*exp(1/2)*erf(sqrt(2)/2)/2 + sqrt(2)*pi*exp(1/2)/2)*exp(-1/2)/(2*pi)","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The familiar  answer could be found by calling N or evalf.","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"We show one more distribution, the uniform over ab:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> @syms a::real b::real\n(a, b)\n\njulia> U = stats.Uniform(\"U\", a, b)\nPython: U\n\njulia> stats.E(U) |> simplify |> println\na/2 + b/2\n\njulia> stats.variance(U) |> Sym |> simplify |> factor |> println\n(a - b)^2/12","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"Not all outputs are so simple to incorporate. PythonCall does a good job of converting the arguments from Julia to Python, but the conversion from a Python (SymPy) structure back to a workable Julia structure can require some massaging.","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The output of many integration problems is a piecewise function:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> @syms n::integer x::real\n(n, x)\n\njulia> u = integrate(x^n, x)\nPiecewise((x^(n + 1)/(n + 1), Ne(n, -1)), (log(x), True))","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The u object is of type Sym, but there are no methods for working with it. The .args call will break this into its argument, which again will by symbolic. We call the .py attribute of the Sym object to get an iterable:","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"julia> [Sym(t[1]) => Sym(t[0]) for t ∈ u.args.py]\n2-element Vector{Pair{Sym, Sym}}:\n Ne(n, -1) => x^(n + 1)/(n + 1)\n      True => log(x)","category":"page"},{"location":"overview/","page":"Basic overview","title":"Basic overview","text":"The python objects are iterated over, so 0-based indexing is used above. These pieces are then converted to Sym objects for familiarity.","category":"page"},{"location":"","page":"SymPyPythonCall","title":"SymPyPythonCall","text":"CurrentModule = SymPyPythonCall","category":"page"},{"location":"#SymPyPythonCall","page":"SymPyPythonCall","title":"SymPyPythonCall","text":"","category":"section"},{"location":"","page":"SymPyPythonCall","title":"SymPyPythonCall","text":"Documentation for SymPyPythonCall.","category":"page"},{"location":"","page":"SymPyPythonCall","title":"SymPyPythonCall","text":"SymPy is Python library for symbolic mathematics.","category":"page"},{"location":"","page":"SymPyPythonCall","title":"SymPyPythonCall","text":"SymPy.jl is a Julia package using PyCall.jl to provide a \"Julian\" interface to SymPy.","category":"page"},{"location":"","page":"SymPyPythonCall","title":"SymPyPythonCall","text":"SymPyPythonCall.jl is a Julia package using PythonCall.jl to provide a \"Julian\" interface to SymPy providing a nearly identical experience as SymPy.jl.","category":"page"},{"location":"","page":"SymPyPythonCall","title":"SymPyPythonCall","text":"This package started as a proof of concept to see if PythonCall could be used to make SymPy.jl either faster or easier to maintain. It may prove useful as an alternative, given the ease to install additional python packages provided by PythonCall and its ecosystem.","category":"page"},{"location":"docstrings/#Docstrings","page":"Docstrings","title":"Docstrings","text":"","category":"section"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"","category":"page"},{"location":"docstrings/","page":"Docstrings","title":"Docstrings","text":"Modules = [SymPyPythonCall]","category":"page"},{"location":"docstrings/#SymPyPythonCall.SymPyPythonCall","page":"Docstrings","title":"SymPyPythonCall.SymPyPythonCall","text":"SymPyPythonCall\n\nModule to call Python's SymPy package from Julia using PythonCall\n\n\n\n\n\n","category":"module"},{"location":"docstrings/#SymPyPythonCall.sympy_plotting","page":"Docstrings","title":"SymPyPythonCall.sympy_plotting","text":"Plotting of symbolic objects.\n\nThe Plots package provide a uniform interface to many of Julia's plotting packages. SymPy plugs into Plots' \"recipes.\"\n\nThe basic goal is that when Plots provides an interface for function objects, this package extends the interface to symbolic expressions.\n\nIn particular:\n\nplot(ex::Sym, a, b; kwargs...) will plot a function evaluating ex over [a,b]\n\nExample. Here we use the default backend for Plots to make a plot:\n\nusing Plots\n@syms x\nplot(x^2 - 2x, 0, 4)\n\nplot(ex1, ex2, a, b; kwargs...) will plot the two expressions in a parametric plot over the interval [a,b].\n\nExample:\n\n@syms x\nplot(sin(2x), cos(3x), 0, 4pi) ## also\n\nFor a few backends (those that support :path3d) a third symbolic expression may be added to have a 3d parametric plot rendered:\n\nplot(sin(x), cos(x), x, 0, 4pi) # helix in 3d\n\nplot(xs, ys, expression) will make a contour plot (for many backends).\n\n@syms x y\nplot(range(0,stop=5, length=50), range(0,stop=5, length=50), x*y)\n\nTo plot the surface  z=ex(x,y) over a region we have Plots.surface. For example,\n\n@syms x y\nsurface(-5:5, -5:5, 25 - x^2 - y^2)\n\na vectorfield plot can (inefficiently but directly) be produced following this example:\n\nfunction vfieldplot(fx, fy; xlim=(-5,5), ylim=(-5,5), n=8)\n    xs = range(xlim[1], stop=xlim[2], length=n)\n    ys = range(ylim[1], stop=ylim[2], length=n)\n\n    us = vec([x for x in xs, y in ys])\n    vs = vec([y for x in xs, y in ys])\n    fxs = vec([fx(x,y) for x in xs, y in ys])\n    fys = vec([fy(x,y) for x in xs, y in ys])\n\n    mxs = maximum(abs.(filter(!isinf, filter(!isnan, fxs))))\n    mys = maximum(abs.(filter(!isinf, filter(!isnan, fys))))\n    d = 1/2 * max((xlim[2]-xlim[1])/mxs, (ylim[2]-ylim[1])/mys) / n\n\n    quiver(us, vs, quiver=(fxs.*d, fys.*d))\n\nend\nfx = (x + y) / sqrt(x^2 + y^2)\nfy = (x - y) / sqrt(x^2 + y^2)\nvfieldplot(fx, fy)\n\n\n\nTo plot two or more functions at once, the style plot([ex1, ex2], a, b) does not work. Rather, use   plot(ex1, a, b); plot!(ex2), as in:\n\n@syms x\nplot(sin(x), 0, 2pi)\nplot!(cos(x))\n\n\n\nSome graphics provided by SymPy are available if PyPlot is installed, such as:\n\nsympy.plotting.plot3d_parametric_surface\nsympy.plotting.plot_implicit\n\nPlot the parametrically defined surface [exs[1](u,v), exs[2](u,v), exs[3](u,v)] over [a0,a1] x [b0,b1]. The specification of the variables uses a tuple of the form (Sym, Real, Real) following the style of SymPy in integrate, say, where disambiguation of variable names is needed.\n\n@syms theta, phi\nr = 1\nsympy.plotting.plot3d_parametric_surface((r*sin(theta)*sin(phi), r*sin(theta)*cos(phi), r*cos(theta)),\n                        (theta, 0, pi), (phi, 0, pi/2))\n\nsympy.plotting.plot_implicit(equation, (xvar, x0, x1), (yvar, y0, y1)) will plot implicitly the equation.\n\n@syms x y\nsympy.plotting.plot_implicit(Eq(x^2+ y^2,3), (x, -2, 2), (y, -2, 2))  # draw a circle\n\n\n\n\n\n","category":"constant"},{"location":"docstrings/#SymPyPythonCall.Differential","page":"Docstrings","title":"SymPyPythonCall.Differential","text":"Differential(x)\n\nUse to find (partial) derivatives.\n\nExample\n\n@syms x y u()\nDx = Differential(x)\nDx(u(x,y))  # resolves to diff(u(x,y),x)\nDx(u)       # will evaluate diff(u(x), x)\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#SymPyPythonCall.VectorField","page":"Docstrings","title":"SymPyPythonCall.VectorField","text":"VectorField(fx, fy): create an object that can be plotted as a vector field.\n\nA vectorfield plot draws arrows at grid points proportional to [fx(x_i,y_i), fy(x_i,y_i)] to visualize the field generated by [fx, fy].\n\nThe plot command: plot(VectorField(fx, fy), xlims=(-5,5), ylims=(-5,5), n=8) will draw the vectorfield. This uses the default values, so the same graph would be rendered by plot(VectorField(fx,fy)).\n\nTo faciliate the visualization of solution to the ODE y' = F(x, y(x)), the call plot(VectorField(F)) will work. (The order is x then y, though often this is written as F(y(x),x).)\n\nSymPy objects can be passed to VectorField, but this is a bit fragile, as they must each have two variables so that they can be called with two variables.  (E.g., y(1,2) will be 1 not 2, as might be intended.)\n\nExamples:\n\nusing Plots\n\nfx(x,y) = sin(y); fy(x,y) = cos(y)\nplot(VectorField(fx, fy), xlims=(-2pi, 2pi), ylims=(-2pi,2pi))\n\n# plot field of y' = 3y*x over (-5,5) x (-5,5)\nF(x,y) = 3*y*x\nplot(VectorField(F))\n\n# plot field and solution u' = u*(1-u)\n@syms x u()\nF(x,y) = y*(1-y)\nout = dsolve(u'(x) - F(x, u(x)), x, (u, 0, 1))\nplot(VectorField(F), xlims=(0,5), ylims=(0,2))\nplot!(rhs(out))\n\n\n\n\n\n","category":"type"},{"location":"docstrings/#Base.match-Tuple{Sym, Sym, Vararg{Any}}","page":"Docstrings","title":"Base.match","text":"match(pattern, expression, ...)\n\nMatch a pattern against an expression; returns a dictionary of matches.\n\nIf a match is unsuccesful, returns an empty dictionary. (SymPy returns \"nothing\")\n\nThe order of the arguments follows Julia's match function, not sympy.match, which can be used directly, otherwise.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#Base.replace-Tuple{Sym, Sym, Function}","page":"Docstrings","title":"Base.replace","text":"replace(expression, pattern, value, ...)\n\nFrom: SymPy Docs\n\nTraverses an expression tree and performs replacement of matching subexpressions from the bottom to the top of the tree. The default approach is to do the replacement in a simultaneous fashion so changes made are targeted only once. If this is not desired or causes problems, simultaneous can be set to false. In addition, if an expression containing more than one Wild symbol is being used to match subexpressions and the exact flag is true, then the match will only succeed if non-zero values are received for each Wild that appears in the match pattern.\n\nDifferences from SymPy:\n\n\"types\" are specified via calling func on the head of an expression: func(sin(x)) -> sin, or directly through sympy.sin\nfunctions are not supported\n\nExamples (from the SymPy docs)\n\njulia> using SymPyPythonCall\n\njulia> @syms x, y, z\n(x, y, z)\n\njulia> f = log(sin(x)) + tan(sin(x^2)); print(f) # `print(f)` only so doctest can run\nlog(sin(x)) + tan(sin(x^2))\n\n\n\"type\" -> \"type\"\n\nTypes are specified through func:\n\njulia> func = SymPyPythonCall.Introspection.func\nfunc (generic function with 1 method)\n\njulia> replace(f, func(sin(x)), func(cos(x))) |> print  # type -> type\nlog(cos(x)) + tan(cos(x^2))\n\njulia> #replace(f, sympy.sin, sympy.cos)  |>  print  # \"log(cos(x)) + tan(cos(x^2))\" **but fails**\n\njulia> sin(x).replace(func(sin(x)), func(cos(x)), map=true)\n(cos(x), Dict{Sym, Sym}(sin(x) => cos(x)))\n\n\n\"type\" -> \"function\"\n\nXXX\n\n\"pattern\" -> \"expression\"\n\nUsing \"Wild\" variables allows a pattern to be replaced by an expression:\n\njulia> a, b = Wild(\"a\"), Wild(\"b\")\n(a_, b_)\n\njulia> replace(f, sin(a), tan(2a)) |> print\nlog(tan(2*x)) + tan(tan(2*x^2))\n\njulia> replace(f, sin(a), tan(a/2)) |> print\nlog(tan(x/2)) + tan(tan(x^2/2))\n\njulia> f.replace(sin(a), a) |> print\nlog(x) + tan(x^2)\n\njulia> (x*y).replace(a*x, a)\ny\n\n\nIn the SymPy docs we have:\n\nMatching is exact by default when more than one Wild symbol is used: matching fails unless the match gives non-zero values for all Wild symbols.\"\n\njulia> replace(2x + y, a*x+b, b-a)  # y - 2\ny - 2\n\njulia> replace(2x + y, a*x+b, b-a, exact=false)  # y + 2/x\ny + 2/x\n\n\"pattern\" -> \"func\"\n\nXXX\n\n\"func\" -> \"func\"\n\nXXX\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#SymPyPythonCall.Wild-Tuple{AbstractString}","page":"Docstrings","title":"SymPyPythonCall.Wild","text":"Wild(x)\n\ncreate a \"wild card\" for pattern matching\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#SymPyPythonCall.asSymbolic-Tuple{Any}","page":"Docstrings","title":"SymPyPythonCall.asSymbolic","text":"asSymbolic(x)\n\nConvert Python object into symbolic Julia object. Aliased to ↑.\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#SymPyPythonCall.ask-Tuple{Sym, Vararg{Any}}","page":"Docstrings","title":"SymPyPythonCall.ask","text":"ask(query)\n\nReturns true, false, or nothing; ask\n\nExample:\n\njulia> using SymPyPythonCall\n\njulia> @syms x::integer y::integer\n(x, y)\n\njulia> ask(𝑄.integer(x*y), sympy.And(𝑄.integer(x), 𝑄.integer(y)))\ntrue\n\njulia> filter(x -> ask(𝑄.prime(x)), 1:10) ## really slow isprime:\n4-element Vector{Int64}:\n 2\n 3\n 5\n 7\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#SymPyPythonCall.lambdify","page":"Docstrings","title":"SymPyPythonCall.lambdify","text":"lambdify(ex, vars=free_symbols();\n         fns=Dict(), values=Dict, use_julia_code=false,\n         invoke_latest=true)\n\nTake a symbolic expression and return a Julia function or expression to build a function.\n\nex::Sym a symbolic expression with 0, 1, or more free symbols\nvars a container of symbols to use for the function arguments. The default is free_symbols which has a specific ordering. Specifying vars allows this default ordering of arguments to be customized.\nfns::Dict, vals::Dict: Dictionaries that allow customization of the function that walks the expression ex and creates the corresponding AST for a Julia expression. See SymPy.fn_map and SymPy.val_map for the default mappings of sympy functions and values into Julia's AST.\nuse_julia_code::Bool: use SymPy's conversion to an expression, the default is false\ninvoke_latest=true: if true will call eval and Base.invokelatest to return a function that should not have any world age issue. If false will return a Julia expression that can be evaled to produce a function.\n\nExample:\n\njulia> using SymPyPythonCall\n\njulia> @syms x y z\n(x, y, z)\n\njulia> ex = x^2 * sin(x)\nx^2*sin(x)\n\njulia> fn = lambdify(ex);\n\njulia> fn(pi)\n0.0\n\njulia> ex = x + 2y + 3z\nx + 2*y + 3*z\n\njulia> fn = lambdify(ex);\n\njulia> fn(1,2,3) # order is by free_symbols\n14\n\njulia> ex(x=>1, y=>2, z=>3)\n14\n\njulia> fn = lambdify(ex, (y,x,z));\n\njulia> fn(1,2,3)\n13\n\n!!! Note:\n\nThe default produces slower functions due to the calls to eval and Base.invokelatest.  In the following g2 (which, as seen, requires additional work to compute) is as fast as calling f (on non symbolic types), whereas g1 is an order of magnitude slower in this example.\n\njulia> @vars x\n(x,)\n\njulia> f(x) = exp(cot(x))\nf (generic function with 1 method)\n\njulia> g1 = lambdify(f(x))\n#88 (generic function with 1 method)\n\njulia> ex = lambdify(f(x), invoke_latest=false)\n:(function var\"##271\"(x)\n      exp(cot(x))\n  end)\n\njulia> @eval g2(x) = ($ex)(x)\ng2 (generic function with 1 method)\n\nAn alternative, say, is to use GeneralizedGenerated's mk_function, as follows:\n\njulia> using GeneralizedGenerated\n\njulia> body = convert(Expr, f(x))\n:(exp(cot(x)))\n\njulia> g3 = mk_function((:x,), (), body)\nfunction = (x;) -> begin\n    (Main).exp((Main).cot(x))\nend\n\nThis function will be about 2-3 times slower than f.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#SymPyPythonCall.plot_implicit-Tuple{Any, Vararg{Any}}","page":"Docstrings","title":"SymPyPythonCall.plot_implicit","text":"Plot an implicit equation\n\n@syms x y\nplot_implicit(Eq(x^2+ y^2,3), (x, -2, 2), (y, -2, 2))\n\n\n\n\n\n","category":"method"},{"location":"docstrings/#SymPyPythonCall.plot_parametric_surface","page":"Docstrings","title":"SymPyPythonCall.plot_parametric_surface","text":"Render a parametrically defined surface plot.\n\nExample:\n\n@syms u, v\nplot_parametric_surface((u*v,u-v,u+v), (u,0,1), (v,0,1))\n\nThis uses PyPlot, not Plots for now.\n\n\n\n\n\n","category":"function"},{"location":"docstrings/#SymPyPythonCall.refine-Tuple{Any, Vararg{Any}}","page":"Docstrings","title":"SymPyPythonCall.refine","text":" refine\n\nSimplify an expression using assumptions; refine.\n\n\n\n\n\n","category":"method"}]
}
